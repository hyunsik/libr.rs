//! automatically generated by rust-bindgen


pub use super::libextern::*;

#[link(name = "R")]
extern {
    pub static mut R_NaN: ::libc::c_double;
    pub static mut R_PosInf: ::libc::c_double;
    pub static mut R_NegInf: ::libc::c_double;
    pub static mut R_NaReal: ::libc::c_double;
    pub static mut R_NaInt: ::libc::c_int;
}
#[link(name = "R")]
extern {
    pub fn isnan(__value: ::libc::c_double) -> ::libc::c_int;
    pub fn finite(__value: ::libc::c_double) -> ::libc::c_int;
    pub fn R_IsNA(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn R_IsNaN(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn R_finite(arg1: ::libc::c_double) -> ::libc::c_int;
}

pub use self::R_IsNA as ISNA;
pub use self::R_IsNaN as ISNAN;
pub use self::R_finite as R_FINITE;

#[cfg(test)]
mod test {
    use super::*;
    #[test]
    fn test_isnan() {
        unsafe {
            assert_eq!(isnan(1.), 0);
            assert_eq!(isnan(::std::f64::NAN), 1);
            assert_eq!(isnan(1.), ISNAN(1.));
            assert_eq!(isnan(1.), ISNA(1.));
        }
    }
    #[test]
    fn test_finite() {
        unsafe {
            assert!(finite(0.) == 1);
            assert_eq!(finite(0.), R_FINITE(0.));
            assert_eq!(finite(0.), R_finite(0.));
            let infinity = ::std::f64::INFINITY;
            assert!(finite(infinity) == 0);
            assert_eq!(finite(infinity), R_FINITE(infinity));
            assert_eq!(finite(infinity), R_finite(infinity));
        }
    }
}
